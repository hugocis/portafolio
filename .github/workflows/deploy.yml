name: 🚀 Deploy to Invernalia Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: 🌐 Deploy to Production Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: 📂 Checkout repository
        uses: actions/checkout@v4
        
      - name: 🔍 Test server connectivity
        run: |
          echo "🔍 Testing connectivity to server..."
          
          # Test multiple DNS servers
          echo "Testing with different DNS servers..."
          nslookup herokku.duckdns.org 8.8.8.8 || echo "⚠️ DNS resolution with Google DNS failed"
          nslookup herokku.duckdns.org 1.1.1.1 || echo "⚠️ DNS resolution with Cloudflare DNS failed"
          nslookup herokku.duckdns.org || echo "⚠️ DNS resolution with default DNS failed"
          
          # Try to get IP directly from DuckDNS
          echo "Attempting to resolve IP..."
          IP=$(dig +short herokku.duckdns.org @8.8.8.8 | head -n1)
          if [ -n "$IP" ] && [ "$IP" != "" ]; then
            echo "✅ Resolved IP: $IP"
            echo "SERVER_IP=$IP" >> $GITHUB_ENV
          else
            echo "❌ Could not resolve IP"
            # Try common DuckDNS patterns or ask user for IP
            echo "💡 Please check if herokku.duckdns.org is the correct hostname"
            echo "💡 Or provide the IP address directly in secrets as SERVER_IP"
          fi
          
          # Test SSH port with IP if available
          if [ -n "$IP" ]; then
            echo "Testing SSH port with IP $IP..."
            timeout 10s nc -z $IP 7122 && echo "✅ SSH port reachable via IP" || echo "❌ SSH port not reachable via IP"
          fi
          
      - name: �🔐 Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          
      - name: 🌍 Deploy to Invernalia Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_IP || secrets.SERVER_IP || 'herokku.duckdns.org' }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 7122
          timeout: 600s
          command_timeout: 1800s
          script: |
            set -e
            
            echo "🏠 Working directory: $(pwd)"
            echo "👤 User: $(whoami)"
            echo "🌐 Server info: $(uname -a)"
            
            # Test connectivity from server side
            echo "🔍 Testing server connectivity..."
            ping -c 2 8.8.8.8 > /dev/null && echo "✅ Internet connectivity OK" || echo "⚠️ Limited internet connectivity"
            
            # Test DNS resolution from server
            echo "🔍 Testing DNS from server..."
            nslookup google.com > /dev/null && echo "✅ DNS working" || echo "⚠️ DNS issues on server"
            
            # Crear directorio del proyecto si no existe
            PROJECT_DIR="portafolios"
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "📁 Creating project directory..."
              mkdir -p "$PROJECT_DIR"
              cd "$PROJECT_DIR"
              
              echo "📦 Cloning repository..."
              for i in {1..3}; do
                if git clone https://github.com/${{ github.repository }}.git .; then
                  echo "✅ Repository cloned successfully"
                  break
                else
                  echo "⚠️ Clone attempt $i/3 failed"
                  sleep 10
                fi
              done
            else
              echo "📁 Entering existing project directory..."
              cd "$PROJECT_DIR"
            fi
            
            # Verificar que es un repositorio git válido
            if [ ! -d ".git" ]; then
              echo "🔧 Initializing git repository..."
              rm -rf ./* ./.* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
            fi
            
            # Actualizar código con reintentos y mejor manejo de errores
            echo "🔄 Updating code from GitHub..."
            git config --global --add safe.directory $(pwd)
            
            for i in {1..5}; do
              if timeout 60s git fetch origin && git reset --hard origin/main; then
                echo "✅ Git update successful"
                break
              else
                echo "⚠️ Git update failed, attempt $i/5"
                if [ $i -eq 5 ]; then
                  echo "❌ All git update attempts failed"
                  echo "🔄 Continuing with existing code..."
                else
                  sleep 10
                fi
              fi
            done
            git clean -fd || true
            
            # Verificar archivos críticos
            echo "🔍 Checking critical files..."
            ls -la Dockerfile docker-compose*.yml .env* || echo "Some files may be missing"
            
            # SIEMPRE crear archivo .env completo con todos los secrets de GitHub
            echo "📝 Creating complete .env configuration from GitHub Secrets..."
            cat > .env << EOF
            NODE_ENV=production
            PORT=3000
            NEXTAUTH_URL=https://herokku.duckdns.org
            DATABASE_URL=postgresql://postgres:${{ secrets.POSTGRES_PASSWORD }}@db:5432/portafolios
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=portafolios
            OAUTH_GITHUB_ID=${{ secrets.OAUTH_GITHUB_ID }}
            OAUTH_GITHUB_SECRET=${{ secrets.OAUTH_GITHUB_SECRET }}
            CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
            LOG_LEVEL=info
            ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
            ENCRYPTION_IV=${{ secrets.ENCRYPTION_IV }}
            CRON_SECRET_TOKEN=${{ secrets.CRON_SECRET_TOKEN }}
            EOF
            
            echo "✅ .env created with all secrets from GitHub"
            echo "📋 Environment variables configured:"
            echo "   - NODE_ENV=production"
            echo "   - NEXTAUTH_URL=https://herokku.duckdns.org:8443"
            echo "   - DATABASE_URL=postgresql://postgres:****@db:5432/portafolios"
            echo "   - All secrets loaded from GitHub"
            
            # 🔒 Configurar SSL si es necesario
            echo "🔒 Checking SSL configuration..."
            
            if [ ! -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              echo "📝 Attempting SSL setup..."
              
              # Crear directorios necesarios
              mkdir -p certbot/conf certbot/www
              
              # Limpiar contenedores temporales anteriores
              echo "🧹 Cleaning up any previous temporary containers..."
              docker stop certbot-standalone 2>/dev/null || true
              docker rm certbot-standalone 2>/dev/null || true
              docker compose down 2>/dev/null || true
              
              echo "� Attempting to obtain SSL certificate from Let's Encrypt..."
              echo "💡 This requires port 80 to be accessible from the Internet"
              
              # Intentar obtener certificado
              docker run --rm --name certbot-standalone \
                -p 8080:80 \
                -v $(pwd)/certbot/conf:/etc/letsencrypt \
                certbot/certbot certonly \
                --standalone \
                --preferred-challenges http \
                --http-01-port 80 \
                --email ${{ secrets.LETSENCRYPT_EMAIL || 'admin@herokku.duckdns.org' }} \
                --agree-tos \
                --no-eff-email \
                --non-interactive \
                -d herokku.duckdns.org 2>&1 | tee /tmp/certbot.log
              
              # Verificar resultado
              if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
                echo "✅ SSL certificate obtained successfully!"
              else
                echo "⚠️ Could not obtain SSL certificate"
                echo "� Reason: Port 80 not accessible from Internet (firewall/NAT)"
                echo ""
                echo "💡 Solutions:"
                echo "   1. Configure port forwarding: 80 -> 8080 in your router"
                echo "   2. Use Cloudflare for automatic SSL (see HTTPS_SETUP.md)"
                echo "   3. Continue with HTTP on port 8130"
                echo ""
                echo "📝 For now, deploying with HTTP..."
              fi
            else
              echo "✅ SSL certificates already exist"
            fi
            
            # Verificar Docker
            echo "🐳 Checking Docker installation..."
            if ! docker --version; then
              echo "❌ Docker not installed"
              exit 1
            fi
            
            if ! docker compose version; then
              echo "❌ Docker Compose not available"
              exit 1
            fi
            
            # Test Docker functionality
            echo "🔍 Testing Docker functionality..."
            if timeout 60s docker run --rm hello-world > /dev/null 2>&1; then
              echo "✅ Docker working properly"
            else
              echo "⚠️ Docker may have connectivity issues"
            fi
            
            # Verificar conflictos de puertos antes del deploy
            echo "🔍 Checking for port conflicts..."
            
            # Verificar puerto 8130 (aplicación)
            if ss -tlnp 2>/dev/null | grep -q ":8130 "; then
              echo "⚠️ Port 8130 is in use. Checking what's using it..."
              ss -tlnp 2>/dev/null | grep ":8130 "
              echo "🛑 Attempting to stop any existing instances..."
              docker compose -f docker-compose.yml -f docker-compose.server.yml down || true
              pkill -f ":8130" || true
              sleep 5
            else
              echo "✅ Port 8130 available"
            fi
            
            # Verificar puerto 5432 (PostgreSQL)
            if ss -tlnp 2>/dev/null | grep -q ":5432 "; then
              echo "⚠️ Port 5432 is in use (PostgreSQL conflict detected)"
              ss -tlnp 2>/dev/null | grep ":5432 "
              echo "📝 Note: Using internal-only PostgreSQL to avoid conflicts"
            else
              echo "✅ Port 5432 available"
            fi
            
            # Mostrar estado actual antes de deploy
            echo "📊 Current Docker status:"
            docker compose ps 2>/dev/null || echo "No containers currently running"
            
            # Detener servicios existentes con timeout
            echo "🛑 Stopping existing services..."
            timeout 120s docker compose -f docker-compose.yml -f docker-compose.server.yml down || echo "Timeout stopping services"
            
            # Limpiar recursos con cuidado
            echo "🧹 Cleaning up resources..."
            docker image prune -f || echo "Could not prune images"
            docker container prune -f || echo "Could not prune containers"
            
            # Verificar espacio en disco
            echo "💾 Checking disk space..."
            df -h . | tail -1
            
            # Estrategia de construcción robusta con detección de conflictos
            echo "🚀 Starting deployment with robust strategy..."
            
            # Configurar variables de entorno para Docker
            export DOCKER_BUILDKIT=1
            export BUILDKIT_PROGRESS=plain
            export COMPOSE_HTTP_TIMEOUT=1800
            export DOCKER_CLIENT_TIMEOUT=1800
            
            # Determinar configuración a usar
            echo "� Using server configuration with Cloudflare Quick Tunnel"
            COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.server.yml"
            
            echo "📋 Using configuration: $COMPOSE_CONFIG"
            
            # Intentar diferentes estrategias
            DEPLOYMENT_SUCCESS=false
            
            # Estrategia 1: Build normal con configuración apropiada
            echo "📋 Strategy 1: Build with appropriate configuration..."
            for attempt in {1..2}; do
              echo "🔨 Build attempt $attempt/2..."
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "✅ Build successful on attempt $attempt"
                DEPLOYMENT_SUCCESS=true
                break
              else
                echo "❌ Build failed on attempt $attempt"
                docker compose $COMPOSE_CONFIG down || true
                if [ $attempt -eq 1 ]; then
                  echo "⏳ Waiting 60 seconds before retry..."
                  sleep 60
                fi
              fi
            done
            
            # Estrategia 2: Usar Dockerfile estable si existe
            if [ "$DEPLOYMENT_SUCCESS" = false ] && [ -f "Dockerfile.stable" ]; then
              echo "📋 Strategy 2: Using stable Dockerfile..."
              
              # Backup y usar Dockerfile estable
              cp Dockerfile Dockerfile.backup 2>/dev/null || true
              cp Dockerfile.stable Dockerfile
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "✅ Deployment successful with stable Dockerfile"
                DEPLOYMENT_SUCCESS=true
              else
                echo "❌ Stable Dockerfile also failed"
                # Restaurar Dockerfile original
                cp Dockerfile.backup Dockerfile 2>/dev/null || true
              fi
            fi
            
            # Estrategia 3: Usar imágenes existentes
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "📋 Strategy 3: Using existing images..."
              
              if docker images | grep -q portafolios; then
                echo "📦 Found existing images, attempting deployment..."
                if docker compose $COMPOSE_CONFIG up -d; then
                  echo "✅ Deployment successful with existing images"
                  DEPLOYMENT_SUCCESS=true
                else
                  echo "❌ Existing images deployment failed"
                fi
              else
                echo "❌ No existing images found"
              fi
            fi
            
            # Verificar resultado del deployment
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "❌ All deployment strategies failed"
              echo "📋 Final logs:"
              docker compose logs --tail=30 2>/dev/null || echo "Could not fetch logs"
              exit 1
            fi
            
            # Esperar a que los servicios se estabilicen
            echo "⏳ Waiting for services to stabilize..."
            sleep 90
            
            # Verificar estado de los servicios
            echo "✅ Final service status:"
            docker compose ps
            
            # Verificar que los contenedores están corriendo
            if ! docker compose ps | grep -q "Up"; then
              echo "❌ No containers are running. Checking logs..."
              docker compose logs --tail=30
              exit 1
            fi
            
            # Mostrar logs recientes de la aplicación
            echo "📋 Recent application logs:"
            docker compose logs --tail=25 app || echo "Could not fetch app logs"
            
            # Test de salud de la aplicación con reintentos
            echo "🔍 Testing application health..."
            
            HEALTH_URL="http://localhost:8130"
            APP_URL="http://localhost:8130"
            
            for i in {1..10}; do
              if curl -f -m 20 ${HEALTH_URL}/api/health 2>/dev/null; then
                echo "✅ Health check successful - API responding"
                break
              elif curl -f -m 20 ${APP_URL} 2>/dev/null; then
                echo "✅ Main application responding"
                break
              else
                echo "⏳ Health check attempt $i/10 failed, retrying in 15s..."
                if [ $i -eq 10 ]; then
                  echo "⚠️ Health checks failed, checking system status..."
                  echo "🔍 Port status:"
                  ss -tlnp 2>/dev/null | grep -E ':(8080|8443|8130) ' || echo "Expected ports not listening"
                  echo "🔍 Process status:"
                  docker compose top 2>/dev/null || echo "Could not get process info"
                  echo "📋 Container logs:"
                  docker compose logs --tail=15 app
                  echo "💡 Application may still be starting up"
                else
                  sleep 15
                fi
              fi
            done
            
            # Información final
            echo "🎉 Deployment process completed!"
            echo ""
            echo "🌐 Application URLs:"
            echo "   - HTTPS: https://herokku.duckdns.org"
            echo "   - HTTP (Direct): http://herokku.duckdns.org:8130"
            echo ""
            echo "🔍 Health endpoint: https://herokku.duckdns.org/api/health"
            echo ""
            echo "✅ SSL/HTTPS enabled via Cloudflare Tunnel"
            echo ""
            echo "📊 Container status:"
            docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            
            echo "💡 If the application is not immediately available:"
            echo "   - Check logs: docker compose logs -f app"
            echo "   - Check status: docker compose ps"
            echo "   - Wait a few more minutes for startup"

  notify:
    name: 📢 Deployment Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: 🎉 Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "✅ Deployment completed successfully!"
          echo "🌐 Application URL with HTTPS:"
          echo "   https://herokku.duckdns.org"
          echo ""
          echo "🔒 SSL enabled via Cloudflare Tunnel"
          echo "📝 Your DuckDNS domain now has HTTPS!"
          
      - name: ❌ Failure Notification
        if: needs.deploy.result == 'failure'
        run: |
          echo "❌ Deployment failed!"
          echo "🔍 Check server connectivity and SSH credentials"
