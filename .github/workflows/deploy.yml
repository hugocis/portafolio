name: 🚀 Deploy to Invernalia Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: 🌐 Deploy to Production Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: 📂 Checkout repository
        uses: actions/checkout@v4
        
      - name: 🔍 Test server connectivity
        run: |
          echo "🔍 Testing connectivity to server..."
          
          # Test multiple DNS servers
          echo "Testing with different DNS servers..."
          nslookup herokku.duckdns.org 8.8.8.8 || echo "⚠️ DNS resolution with Google DNS failed"
          nslookup herokku.duckdns.org 1.1.1.1 || echo "⚠️ DNS resolution with Cloudflare DNS failed"
          nslookup herokku.duckdns.org || echo "⚠️ DNS resolution with default DNS failed"
          
          # Try to get IP directly from DuckDNS
          echo "Attempting to resolve IP..."
          IP=$(dig +short herokku.duckdns.org @8.8.8.8 | head -n1)
          if [ -n "$IP" ] && [ "$IP" != "" ]; then
            echo "✅ Resolved IP: $IP"
            echo "SERVER_IP=$IP" >> $GITHUB_ENV
          else
            echo "❌ Could not resolve IP"
            # Try common DuckDNS patterns or ask user for IP
            echo "💡 Please check if herokku.duckdns.org is the correct hostname"
            echo "💡 Or provide the IP address directly in secrets as SERVER_IP"
          fi
          
          # Test SSH port with IP if available
          if [ -n "$IP" ]; then
            echo "Testing SSH port with IP $IP..."
            timeout 10s nc -z $IP 7122 && echo "✅ SSH port reachable via IP" || echo "❌ SSH port not reachable via IP"
          fi
          
      - name: �🔐 Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          
      - name: 🌍 Deploy to Invernalia Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_IP || secrets.SERVER_IP || 'herokku.duckdns.org' }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 7122
          timeout: 600s
          command_timeout: 1800s
          script: |
            set -e
            
            echo "🏠 Working directory: $(pwd)"
            echo "👤 User: $(whoami)"
            echo "🌐 Server info: $(uname -a)"
            
            # Test connectivity from server side
            echo "🔍 Testing server connectivity..."
            ping -c 2 8.8.8.8 > /dev/null && echo "✅ Internet connectivity OK" || echo "⚠️ Limited internet connectivity"
            
            # Test DNS resolution from server
            echo "🔍 Testing DNS from server..."
            nslookup google.com > /dev/null && echo "✅ DNS working" || echo "⚠️ DNS issues on server"
            
            # Crear directorio del proyecto si no existe
            PROJECT_DIR="portafolios"
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "📁 Creating project directory..."
              mkdir -p "$PROJECT_DIR"
              cd "$PROJECT_DIR"
              
              echo "📦 Cloning repository..."
              for i in {1..3}; do
                if git clone https://github.com/${{ github.repository }}.git .; then
                  echo "✅ Repository cloned successfully"
                  break
                else
                  echo "⚠️ Clone attempt $i/3 failed"
                  sleep 10
                fi
              done
            else
              echo "📁 Entering existing project directory..."
              cd "$PROJECT_DIR"
            fi
            
            # Verificar que es un repositorio git válido
            if [ ! -d ".git" ]; then
              echo "🔧 Initializing git repository..."
              rm -rf ./* ./.* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
            fi
            
            # Actualizar código con reintentos y mejor manejo de errores
            echo "🔄 Updating code from GitHub..."
            git config --global --add safe.directory $(pwd)
            
            for i in {1..5}; do
              if timeout 60s git fetch origin && git reset --hard origin/main; then
                echo "✅ Git update successful"
                break
              else
                echo "⚠️ Git update failed, attempt $i/5"
                if [ $i -eq 5 ]; then
                  echo "❌ All git update attempts failed"
                  echo "🔄 Continuing with existing code..."
                else
                  sleep 10
                fi
              fi
            done
            git clean -fd || true
            
            # Verificar archivos críticos
            echo "🔍 Checking critical files..."
            ls -la Dockerfile docker-compose*.yml .env* || echo "Some files may be missing"
            
            # SIEMPRE crear archivo .env completo con todos los secrets de GitHub
            echo "📝 Creating complete .env configuration from GitHub Secrets..."
            cat > .env << EOF
            NODE_ENV=production
            PORT=3000
            NEXTAUTH_URL=https://herokku.duckdns.org
            DATABASE_URL=postgresql://postgres:${{ secrets.POSTGRES_PASSWORD }}@db:5432/portafolios
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=portafolios
            OAUTH_GITHUB_ID=${{ secrets.OAUTH_GITHUB_ID }}
            OAUTH_GITHUB_SECRET=${{ secrets.OAUTH_GITHUB_SECRET }}
            LOG_LEVEL=info
            ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
            ENCRYPTION_IV=${{ secrets.ENCRYPTION_IV }}
            CRON_SECRET_TOKEN=${{ secrets.CRON_SECRET_TOKEN }}
            EOF
            
            echo "✅ .env created with all secrets from GitHub"
            echo "📋 Environment variables configured:"
            echo "   - NODE_ENV=production"
            echo "   - NEXTAUTH_URL=https://herokku.duckdns.org"
            echo "   - DATABASE_URL=postgresql://postgres:****@db:5432/portafolios"
            echo "   - All secrets loaded from GitHub"
            
            # 🔒 Configurar SSL si es necesario
            echo "🔒 Checking SSL configuration..."
            
            if [ ! -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              echo "📝 First time SSL setup - obtaining certificate..."
              
              # Crear directorios necesarios
              mkdir -p nginx certbot/conf certbot/www
              
              # Limpiar contenedores temporales anteriores
              echo "🧹 Cleaning up any previous temporary containers..."
              docker stop nginx-temp 2>/dev/null || true
              docker rm nginx-temp 2>/dev/null || true
              
              # Verificar si el puerto 80 está en uso y liberarlo
              echo "🔍 Checking port 80 availability..."
              
              # Usar ss en lugar de netstat (más moderno y siempre disponible)
              if ss -tlnp 2>/dev/null | grep -q ":80 " || docker ps --filter "publish=80" | grep -q .; then
                echo "⚠️ Port 80 is in use. Attempting to free it..."
                
                # Intentar detener servicios existentes de Docker que usen el puerto 80
                docker compose down 2>/dev/null || true
                docker ps -q --filter "publish=80" | xargs -r docker stop 2>/dev/null || true
                docker ps -q --filter "publish=443" | xargs -r docker stop 2>/dev/null || true
                
                sleep 3
                
                # Verificar de nuevo
                if ss -tlnp 2>/dev/null | grep -q ":80 " || docker ps --filter "publish=80" | grep -q .; then
                  echo "⚠️ Port 80 still in use. Checking what's using it..."
                  ss -tlnp 2>/dev/null | grep ":80 " || docker ps --filter "publish=80" || true
                  echo "⚠️ Cannot obtain SSL certificate. Will use HTTP for now."
                  echo "💡 To enable HTTPS, ensure port 80 is free and redeploy."
                else
                  echo "✅ Port 80 freed successfully"
                fi
              else
                echo "✅ Port 80 is available"
              fi
              
              # Solo intentar obtener certificado si el puerto 80 está libre
              if ! ss -tlnp 2>/dev/null | grep -q ":80 " && ! docker ps --filter "publish=80" | grep -q .; then
                # Configuración temporal de Nginx para obtener certificado
                cat > nginx/nginx.temp.conf << 'NGINXCONF'
            events {
                worker_connections 1024;
            }
            http {
                server {
                    listen 80;
                    server_name herokku.duckdns.org;
                    location /.well-known/acme-challenge/ {
                        root /var/www/certbot;
                    }
                    location / {
                        return 200 'Obtaining SSL certificate...';
                        add_header Content-Type text/plain;
                    }
                }
            }
            NGINXCONF
                
                # Iniciar Nginx temporal
                echo "🚀 Starting temporary Nginx..."
                docker run -d --name nginx-temp \
                  -p 80:80 \
                  -v $(pwd)/nginx/nginx.temp.conf:/etc/nginx/nginx.conf:ro \
                  -v $(pwd)/certbot/www:/var/www/certbot \
                  nginx:alpine
                
                sleep 5
                
                # Obtener certificado
                echo "🔐 Obtaining SSL certificate from Let's Encrypt..."
                docker run --rm \
                  -v $(pwd)/certbot/conf:/etc/letsencrypt \
                  -v $(pwd)/certbot/www:/var/www/certbot \
                  certbot/certbot certonly \
                  --webroot \
                  --webroot-path=/var/www/certbot \
                  --email ${{ secrets.LETSENCRYPT_EMAIL || 'admin@herokku.duckdns.org' }} \
                  --agree-tos \
                  --no-eff-email \
                  -d herokku.duckdns.org \
                  || echo "⚠️ Certificate generation failed, will retry on next deploy"
                
                # Limpiar Nginx temporal
                echo "🧹 Cleaning up temporary Nginx..."
                docker stop nginx-temp 2>/dev/null || true
                docker rm nginx-temp 2>/dev/null || true
                rm -f nginx/nginx.temp.conf
                
                if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
                  echo "✅ SSL certificate obtained successfully!"
                else
                  echo "⚠️ SSL certificate not obtained, will use HTTP for now"
                fi
              else
                echo "⚠️ Skipping SSL certificate acquisition (port 80 in use)"
              fi
            else
              echo "✅ SSL certificates already exist"
            fi
            
            # Verificar Docker
            echo "🐳 Checking Docker installation..."
            if ! docker --version; then
              echo "❌ Docker not installed"
              exit 1
            fi
            
            if ! docker compose version; then
              echo "❌ Docker Compose not available"
              exit 1
            fi
            
            # Test Docker functionality
            echo "🔍 Testing Docker functionality..."
            if timeout 60s docker run --rm hello-world > /dev/null 2>&1; then
              echo "✅ Docker working properly"
            else
              echo "⚠️ Docker may have connectivity issues"
            fi
            
            # Verificar conflictos de puertos antes del deploy
            echo "🔍 Checking for port conflicts..."
            
            # Verificar puerto 8130 (aplicación)
            if ss -tlnp 2>/dev/null | grep -q ":8130 "; then
              echo "⚠️ Port 8130 is in use. Checking what's using it..."
              ss -tlnp 2>/dev/null | grep ":8130 "
              echo "🛑 Attempting to stop any existing instances..."
              docker compose -f docker-compose.yml -f docker-compose.server.yml down || true
              pkill -f ":8130" || true
              sleep 5
            else
              echo "✅ Port 8130 available"
            fi
            
            # Verificar puerto 5432 (PostgreSQL)
            if ss -tlnp 2>/dev/null | grep -q ":5432 "; then
              echo "⚠️ Port 5432 is in use (PostgreSQL conflict detected)"
              ss -tlnp 2>/dev/null | grep ":5432 "
              echo "📝 Note: Using internal-only PostgreSQL to avoid conflicts"
            else
              echo "✅ Port 5432 available"
            fi
            
            # Mostrar estado actual antes de deploy
            echo "📊 Current Docker status:"
            docker compose ps 2>/dev/null || echo "No containers currently running"
            
            # Detener servicios existentes con timeout
            echo "🛑 Stopping existing services..."
            timeout 120s docker compose -f docker-compose.yml -f docker-compose.server.yml down || echo "Timeout stopping services"
            
            # Limpiar recursos con cuidado
            echo "🧹 Cleaning up resources..."
            docker image prune -f || echo "Could not prune images"
            docker container prune -f || echo "Could not prune containers"
            
            # Verificar espacio en disco
            echo "💾 Checking disk space..."
            df -h . | tail -1
            
            # Estrategia de construcción robusta con detección de conflictos
            echo "🚀 Starting deployment with robust strategy..."
            
            # Configurar variables de entorno para Docker
            export DOCKER_BUILDKIT=1
            export BUILDKIT_PROGRESS=plain
            export COMPOSE_HTTP_TIMEOUT=1800
            export DOCKER_CLIENT_TIMEOUT=1800
            
            # Determinar configuración a usar basada en SSL y conflictos de puerto
            if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              echo "🔒 Using HTTPS configuration"
              COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.https.yml"
            elif ss -tlnp 2>/dev/null | grep -q ":5432 "; then
              echo "⚠️ PostgreSQL port conflict detected, using no-conflict configuration"
              COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.noconflict.yml"
              
              # Crear configuración temporal si no existe
              if [ ! -f docker-compose.noconflict.yml ]; then
                echo "📝 Creating temporary no-conflict configuration..."
                cat > docker-compose.noconflict.yml << 'EOF'
            services:
              app:
                ports:
                  - "8130:3000"
                environment:
                  - NODE_ENV=production
                  - NEXTAUTH_URL=http://herokku.duckdns.org:8130
                  - DATABASE_URL=postgresql://postgres:postgres@db:5432/portafolios
                volumes: []
                restart: unless-stopped
              db:
                environment:
                  - POSTGRES_USER=postgres
                  - POSTGRES_PASSWORD=postgres-servidor
                  - POSTGRES_DB=portafolios
                restart: unless-stopped
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U postgres"]
                  interval: 30s
                  timeout: 10s
                  retries: 5
            EOF
              fi
            else
              echo "✅ No SSL yet, using standard server configuration"
              COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.server.yml"
            fi
            
            echo "📋 Using configuration: $COMPOSE_CONFIG"
            
            # Intentar diferentes estrategias
            DEPLOYMENT_SUCCESS=false
            
            # Estrategia 1: Build normal con configuración apropiada
            echo "📋 Strategy 1: Build with appropriate configuration..."
            for attempt in {1..2}; do
              echo "🔨 Build attempt $attempt/2..."
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "✅ Build successful on attempt $attempt"
                DEPLOYMENT_SUCCESS=true
                break
              else
                echo "❌ Build failed on attempt $attempt"
                docker compose $COMPOSE_CONFIG down || true
                if [ $attempt -eq 1 ]; then
                  echo "⏳ Waiting 60 seconds before retry..."
                  sleep 60
                fi
              fi
            done
            
            # Estrategia 2: Usar Dockerfile estable si existe
            if [ "$DEPLOYMENT_SUCCESS" = false ] && [ -f "Dockerfile.stable" ]; then
              echo "📋 Strategy 2: Using stable Dockerfile..."
              
              # Backup y usar Dockerfile estable
              cp Dockerfile Dockerfile.backup 2>/dev/null || true
              cp Dockerfile.stable Dockerfile
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "✅ Deployment successful with stable Dockerfile"
                DEPLOYMENT_SUCCESS=true
              else
                echo "❌ Stable Dockerfile also failed"
                # Restaurar Dockerfile original
                cp Dockerfile.backup Dockerfile 2>/dev/null || true
              fi
            fi
            
            # Estrategia 3: Usar imágenes existentes
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "📋 Strategy 3: Using existing images..."
              
              if docker images | grep -q portafolios; then
                echo "📦 Found existing images, attempting deployment..."
                if docker compose $COMPOSE_CONFIG up -d; then
                  echo "✅ Deployment successful with existing images"
                  DEPLOYMENT_SUCCESS=true
                else
                  echo "❌ Existing images deployment failed"
                fi
              else
                echo "❌ No existing images found"
              fi
            fi
            
            # Verificar resultado del deployment
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "❌ All deployment strategies failed"
              echo "📋 Final logs:"
              docker compose logs --tail=30 2>/dev/null || echo "Could not fetch logs"
              exit 1
            fi
            
            # Esperar a que los servicios se estabilicen
            echo "⏳ Waiting for services to stabilize..."
            sleep 90
            
            # Verificar estado de los servicios
            echo "✅ Final service status:"
            docker compose ps
            
            # Verificar que los contenedores están corriendo
            if ! docker compose ps | grep -q "Up"; then
              echo "❌ No containers are running. Checking logs..."
              docker compose logs --tail=30
              exit 1
            fi
            
            # Mostrar logs recientes de la aplicación
            echo "📋 Recent application logs:"
            docker compose logs --tail=25 app || echo "Could not fetch app logs"
            
            # Test de salud de la aplicación con reintentos
            echo "🔍 Testing application health..."
            
            # Determinar URL de health check según configuración
            if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              HEALTH_URL="https://localhost"
              APP_URL="https://localhost"
            else
              HEALTH_URL="http://localhost:8130"
              APP_URL="http://localhost:8130"
            fi
            
            for i in {1..10}; do
              if curl -f -m 20 -k ${HEALTH_URL}/api/health 2>/dev/null; then
                echo "✅ Health check successful - API responding"
                break
              elif curl -f -m 20 -k ${APP_URL} 2>/dev/null; then
                echo "✅ Main application responding"
                break
              else
                echo "⏳ Health check attempt $i/10 failed, retrying in 15s..."
                if [ $i -eq 10 ]; then
                  echo "⚠️ Health checks failed, checking system status..."
                  echo "🔍 Port status:"
                  ss -tlnp 2>/dev/null | grep -E ':(80|443|8130) ' || echo "Expected ports not listening"
                  echo "🔍 Process status:"
                  docker compose top 2>/dev/null || echo "Could not get process info"
                  echo "📋 Container logs:"
                  docker compose logs --tail=15 app
                  echo "💡 Application may still be starting up"
                else
                  sleep 15
                fi
              fi
            done
            
            # Información final
            echo "🎉 Deployment process completed!"
            
            if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              echo "🌐 Application available at: https://herokku.duckdns.org"
              echo "🔍 Health endpoint: https://herokku.duckdns.org/api/health"
              echo "🔒 SSL/HTTPS enabled"
            else
              echo "🌐 Application available at: http://herokku.duckdns.org:8130"
              echo "🔍 Health endpoint: http://herokku.duckdns.org:8130/api/health"
              echo "⚠️ HTTP only (SSL will be configured on next deploy)"
            fi
            
            echo "📊 Container status:"
            docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            
            echo "💡 If the application is not immediately available:"
            echo "   - Check logs: docker compose logs -f app"
            echo "   - Check status: docker compose ps"
            echo "   - Wait a few more minutes for startup"

  notify:
    name: 📢 Deployment Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: 🎉 Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "✅ Deployment completed successfully!"
          echo "🌐 Application URL: https://herokku.duckdns.org (or HTTP on first deploy)"
          echo "🔍 Health check: https://herokku.duckdns.org/api/health"
          echo "💡 SSL certificate will be automatically obtained on first deploy"
          
      - name: ❌ Failure Notification
        if: needs.deploy.result == 'failure'
        run: |
          echo "❌ Deployment failed!"
          echo "🔍 Check server connectivity and SSH credentials"
