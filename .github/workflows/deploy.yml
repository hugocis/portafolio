name: ğŸš€ Deploy to Invernalia Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: ğŸŒ Deploy to Production Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: ğŸ“‚ Checkout repository
        uses: actions/checkout@v4
        
      - name: ğŸ” Test server connectivity
        run: |
          echo "ğŸ” Testing connectivity to server..."
          
          # Test multiple DNS servers
          echo "Testing with different DNS servers..."
          nslookup herokku.duckdns.org 8.8.8.8 || echo "âš ï¸ DNS resolution with Google DNS failed"
          nslookup herokku.duckdns.org 1.1.1.1 || echo "âš ï¸ DNS resolution with Cloudflare DNS failed"
          nslookup herokku.duckdns.org || echo "âš ï¸ DNS resolution with default DNS failed"
          
          # Try to get IP directly from DuckDNS
          echo "Attempting to resolve IP..."
          IP=$(dig +short herokku.duckdns.org @8.8.8.8 | head -n1)
          if [ -n "$IP" ] && [ "$IP" != "" ]; then
            echo "âœ… Resolved IP: $IP"
            echo "SERVER_IP=$IP" >> $GITHUB_ENV
          else
            echo "âŒ Could not resolve IP"
            # Try common DuckDNS patterns or ask user for IP
            echo "ğŸ’¡ Please check if herokku.duckdns.org is the correct hostname"
            echo "ğŸ’¡ Or provide the IP address directly in secrets as SERVER_IP"
          fi
          
          # Test SSH port with IP if available
          if [ -n "$IP" ]; then
            echo "Testing SSH port with IP $IP..."
            timeout 10s nc -z $IP 7122 && echo "âœ… SSH port reachable via IP" || echo "âŒ SSH port not reachable via IP"
          fi
          
      - name: ï¿½ğŸ” Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          
      - name: ğŸŒ Deploy to Invernalia Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_IP || secrets.SERVER_IP || 'herokku.duckdns.org' }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 7122
          timeout: 600s
          command_timeout: 1800s
          script: |
            set -e
            
            echo "ğŸ  Working directory: $(pwd)"
            echo "ğŸ‘¤ User: $(whoami)"
            echo "ğŸŒ Server info: $(uname -a)"
            
            # Test connectivity from server side
            echo "ğŸ” Testing server connectivity..."
            ping -c 2 8.8.8.8 > /dev/null && echo "âœ… Internet connectivity OK" || echo "âš ï¸ Limited internet connectivity"
            
            # Test DNS resolution from server
            echo "ğŸ” Testing DNS from server..."
            nslookup google.com > /dev/null && echo "âœ… DNS working" || echo "âš ï¸ DNS issues on server"
            
            # Crear directorio del proyecto si no existe
            PROJECT_DIR="portafolios"
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "ğŸ“ Creating project directory..."
              mkdir -p "$PROJECT_DIR"
              cd "$PROJECT_DIR"
              
              echo "ğŸ“¦ Cloning repository..."
              for i in {1..3}; do
                if git clone https://github.com/${{ github.repository }}.git .; then
                  echo "âœ… Repository cloned successfully"
                  break
                else
                  echo "âš ï¸ Clone attempt $i/3 failed"
                  sleep 10
                fi
              done
            else
              echo "ğŸ“ Entering existing project directory..."
              cd "$PROJECT_DIR"
            fi
            
            # Verificar que es un repositorio git vÃ¡lido
            if [ ! -d ".git" ]; then
              echo "ğŸ”§ Initializing git repository..."
              rm -rf ./* ./.* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
            fi
            
            # Actualizar cÃ³digo con reintentos y mejor manejo de errores
            echo "ğŸ”„ Updating code from GitHub..."
            git config --global --add safe.directory $(pwd)
            
            for i in {1..5}; do
              if timeout 60s git fetch origin && git reset --hard origin/main; then
                echo "âœ… Git update successful"
                break
              else
                echo "âš ï¸ Git update failed, attempt $i/5"
                if [ $i -eq 5 ]; then
                  echo "âŒ All git update attempts failed"
                  echo "ğŸ”„ Continuing with existing code..."
                else
                  sleep 10
                fi
              fi
            done
            git clean -fd || true
            
            # Verificar archivos crÃ­ticos
            echo "ğŸ” Checking critical files..."
            ls -la Dockerfile docker-compose*.yml .env* || echo "Some files may be missing"
            
            # Crear archivo .env para el servidor
            echo "ğŸ“ Setting up environment configuration..."
            if [ ! -f .env ]; then
              if [ -f .env.server ]; then
                cp .env.server .env
                echo "âœ… Using .env.server"
              elif [ -f .env.example ]; then
                cp .env.example .env
                echo "âœ… Using .env.example"
              else
                echo "ğŸ“ Creating basic .env..."
                cat > .env << EOF
            NODE_ENV=production
            NEXTAUTH_URL=http://herokku.duckdns.org:8130
            DATABASE_URL=postgresql://postgres:${{ secrets.POSTGRES_PASSWORD }}@db:5432/portafolios
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=portafolios
            GITHUB_CLIENT_ID=${{ secrets.GITHUB_CLIENT_ID }}
            GITHUB_CLIENT_SECRET=${{ secrets.GITHUB_CLIENT_SECRET }}
            ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
            ENCRYPTION_IV=${{ secrets.ENCRYPTION_IV }}
            CRON_SECRET_TOKEN=${{ secrets.CRON_SECRET_TOKEN }}
            EOF
              fi
            else
              echo "âœ… .env already exists"
            fi
            
            # Verificar Docker
            echo "ğŸ³ Checking Docker installation..."
            if ! docker --version; then
              echo "âŒ Docker not installed"
              exit 1
            fi
            
            if ! docker compose version; then
              echo "âŒ Docker Compose not available"
              exit 1
            fi
            
            # Test Docker functionality
            echo "ğŸ” Testing Docker functionality..."
            if timeout 60s docker run --rm hello-world > /dev/null 2>&1; then
              echo "âœ… Docker working properly"
            else
              echo "âš ï¸ Docker may have connectivity issues"
            fi
            
            # Verificar conflictos de puertos antes del deploy
            echo "ğŸ” Checking for port conflicts..."
            
            # Verificar puerto 8130 (aplicaciÃ³n)
            if netstat -tlnp | grep -q ":8130 "; then
              echo "âš ï¸ Port 8130 is in use. Checking what's using it..."
              netstat -tlnp | grep ":8130 "
              echo "ğŸ›‘ Attempting to stop any existing instances..."
              docker compose -f docker-compose.yml -f docker-compose.server.yml down || true
              pkill -f ":8130" || true
              sleep 5
            else
              echo "âœ… Port 8130 available"
            fi
            
            # Verificar puerto 5432 (PostgreSQL)
            if netstat -tlnp | grep -q ":5432 "; then
              echo "âš ï¸ Port 5432 is in use (PostgreSQL conflict detected)"
              netstat -tlnp | grep ":5432 "
              echo "ğŸ“ Note: Using internal-only PostgreSQL to avoid conflicts"
            else
              echo "âœ… Port 5432 available"
            fi
            
            # Mostrar estado actual antes de deploy
            echo "ğŸ“Š Current Docker status:"
            docker compose ps 2>/dev/null || echo "No containers currently running"
            
            # Detener servicios existentes con timeout
            echo "ğŸ›‘ Stopping existing services..."
            timeout 120s docker compose -f docker-compose.yml -f docker-compose.server.yml down || echo "Timeout stopping services"
            
            # Limpiar recursos con cuidado
            echo "ğŸ§¹ Cleaning up resources..."
            docker image prune -f || echo "Could not prune images"
            docker container prune -f || echo "Could not prune containers"
            
            # Verificar espacio en disco
            echo "ğŸ’¾ Checking disk space..."
            df -h . | tail -1
            
            # Estrategia de construcciÃ³n robusta con detecciÃ³n de conflictos
            echo "ğŸš€ Starting deployment with robust strategy..."
            
            # Configurar variables de entorno para Docker
            export DOCKER_BUILDKIT=1
            export BUILDKIT_PROGRESS=plain
            export COMPOSE_HTTP_TIMEOUT=1800
            export DOCKER_CLIENT_TIMEOUT=1800
            
            # Determinar configuraciÃ³n a usar basada en conflictos de puerto
            if netstat -tlnp | grep -q ":5432 "; then
              echo "âš ï¸ PostgreSQL port conflict detected, using no-conflict configuration"
              COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.noconflict.yml"
              
              # Crear configuraciÃ³n temporal si no existe
              if [ ! -f docker-compose.noconflict.yml ]; then
                echo "ğŸ“ Creating temporary no-conflict configuration..."
                cat > docker-compose.noconflict.yml << 'EOF'
            services:
              app:
                ports:
                  - "8130:3000"
                environment:
                  - NODE_ENV=production
                  - NEXTAUTH_URL=http://herokku.duckdns.org:8130
                  - DATABASE_URL=postgresql://postgres:postgres@db:5432/portafolios
                volumes: []
                restart: unless-stopped
              db:
                environment:
                  - POSTGRES_USER=postgres
                  - POSTGRES_PASSWORD=postgres-servidor
                  - POSTGRES_DB=portafolios
                restart: unless-stopped
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U postgres"]
                  interval: 30s
                  timeout: 10s
                  retries: 5
            EOF
              fi
            else
              echo "âœ… No port conflicts, using standard server configuration"
              COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.server.yml"
            fi
            
            echo "ğŸ“‹ Using configuration: $COMPOSE_CONFIG"
            
            # Intentar diferentes estrategias
            DEPLOYMENT_SUCCESS=false
            
            # Estrategia 1: Build normal con configuraciÃ³n apropiada
            echo "ğŸ“‹ Strategy 1: Build with appropriate configuration..."
            for attempt in {1..2}; do
              echo "ğŸ”¨ Build attempt $attempt/2..."
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "âœ… Build successful on attempt $attempt"
                DEPLOYMENT_SUCCESS=true
                break
              else
                echo "âŒ Build failed on attempt $attempt"
                docker compose $COMPOSE_CONFIG down || true
                if [ $attempt -eq 1 ]; then
                  echo "â³ Waiting 60 seconds before retry..."
                  sleep 60
                fi
              fi
            done
            
            # Estrategia 2: Usar Dockerfile estable si existe
            if [ "$DEPLOYMENT_SUCCESS" = false ] && [ -f "Dockerfile.stable" ]; then
              echo "ğŸ“‹ Strategy 2: Using stable Dockerfile..."
              
              # Backup y usar Dockerfile estable
              cp Dockerfile Dockerfile.backup 2>/dev/null || true
              cp Dockerfile.stable Dockerfile
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "âœ… Deployment successful with stable Dockerfile"
                DEPLOYMENT_SUCCESS=true
              else
                echo "âŒ Stable Dockerfile also failed"
                # Restaurar Dockerfile original
                cp Dockerfile.backup Dockerfile 2>/dev/null || true
              fi
            fi
            
            # Estrategia 3: Usar imÃ¡genes existentes
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "ğŸ“‹ Strategy 3: Using existing images..."
              
              if docker images | grep -q portafolios; then
                echo "ğŸ“¦ Found existing images, attempting deployment..."
                if docker compose $COMPOSE_CONFIG up -d; then
                  echo "âœ… Deployment successful with existing images"
                  DEPLOYMENT_SUCCESS=true
                else
                  echo "âŒ Existing images deployment failed"
                fi
              else
                echo "âŒ No existing images found"
              fi
            fi
            
            # Verificar resultado del deployment
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "âŒ All deployment strategies failed"
              echo "ğŸ“‹ Final logs:"
              docker compose logs --tail=30 2>/dev/null || echo "Could not fetch logs"
              exit 1
            fi
            
            # Esperar a que los servicios se estabilicen
            echo "â³ Waiting for services to stabilize..."
            sleep 90
            
            # Verificar estado de los servicios
            echo "âœ… Final service status:"
            docker compose ps
            
            # Verificar que los contenedores estÃ¡n corriendo
            if ! docker compose ps | grep -q "Up"; then
              echo "âŒ No containers are running. Checking logs..."
              docker compose logs --tail=30
              exit 1
            fi
            
            # Mostrar logs recientes de la aplicaciÃ³n
            echo "ğŸ“‹ Recent application logs:"
            docker compose logs --tail=25 app || echo "Could not fetch app logs"
            
            # Test de salud de la aplicaciÃ³n con reintentos
            echo "ğŸ” Testing application health..."
            
            for i in {1..10}; do
              if curl -f -m 20 http://localhost:8130/api/health 2>/dev/null; then
                echo "âœ… Health check successful - API responding"
                break
              elif curl -f -m 20 http://localhost:8130 2>/dev/null; then
                echo "âœ… Main application responding"
                break
              else
                echo "â³ Health check attempt $i/10 failed, retrying in 15s..."
                if [ $i -eq 10 ]; then
                  echo "âš ï¸ Health checks failed, checking system status..."
                  echo "ğŸ” Port status:"
                  netstat -tlnp | grep :8130 || echo "Port 8130 not listening"
                  echo "ğŸ” Process status:"
                  docker compose top 2>/dev/null || echo "Could not get process info"
                  echo "ğŸ“‹ Container logs:"
                  docker compose logs --tail=15 app
                  echo "ğŸ’¡ Application may still be starting up"
                else
                  sleep 15
                fi
              fi
            done
            
            # InformaciÃ³n final
            echo "ğŸ‰ Deployment process completed!"
            echo "ğŸŒ Application should be available at: http://herokku.duckdns.org:8130"
            echo "ğŸ” Health endpoint: http://herokku.duckdns.org:8130/api/health"
            echo "ğŸ“Š Container status:"
            docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            
            echo "ğŸ’¡ If the application is not immediately available:"
            echo "   - Check logs: docker compose logs -f app"
            echo "   - Check status: docker compose ps"
            echo "   - Wait a few more minutes for startup"

  notify:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: ğŸ‰ Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸŒ Application URL: http://herokku.duckdns.org:8130"
          echo "ğŸ” Health check: http://herokku.duckdns.org:8130/api/health"
          
      - name: âŒ Failure Notification
        if: needs.deploy.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ” Check server connectivity and SSH credentials"
