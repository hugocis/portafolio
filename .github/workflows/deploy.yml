name: ğŸš€ Deploy to Invernalia Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: ğŸŒ Deploy to Production Server
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: ğŸ“‚ Checkout repository
        uses: actions/checkout@v4
        
      - name: ğŸ” Test server connectivity
        run: |
          echo "ğŸ” Testing connectivity to server..."
          
          # Test multiple DNS servers
          echo "Testing with different DNS servers..."
          nslookup herokku.duckdns.org 8.8.8.8 || echo "âš ï¸ DNS resolution with Google DNS failed"
          nslookup herokku.duckdns.org 1.1.1.1 || echo "âš ï¸ DNS resolution with Cloudflare DNS failed"
          nslookup herokku.duckdns.org || echo "âš ï¸ DNS resolution with default DNS failed"
          
          # Try to get IP directly from DuckDNS
          echo "Attempting to resolve IP..."
          IP=$(dig +short herokku.duckdns.org @8.8.8.8 | head -n1)
          if [ -n "$IP" ] && [ "$IP" != "" ]; then
            echo "âœ… Resolved IP: $IP"
            echo "SERVER_IP=$IP" >> $GITHUB_ENV
          else
            echo "âŒ Could not resolve IP"
            # Try common DuckDNS patterns or ask user for IP
            echo "ğŸ’¡ Please check if herokku.duckdns.org is the correct hostname"
            echo "ğŸ’¡ Or provide the IP address directly in secrets as SERVER_IP"
          fi
          
          # Test SSH port with IP if available
          if [ -n "$IP" ]; then
            echo "Testing SSH port with IP $IP..."
            timeout 10s nc -z $IP 7122 && echo "âœ… SSH port reachable via IP" || echo "âŒ SSH port not reachable via IP"
          fi
          
      - name: ï¿½ğŸ” Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          
      - name: ğŸŒ Deploy to Invernalia Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_IP || secrets.SERVER_IP || 'herokku.duckdns.org' }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 7122
          timeout: 600s
          command_timeout: 1800s
          script: |
            set -e
            
            echo "ğŸ  Working directory: $(pwd)"
            echo "ğŸ‘¤ User: $(whoami)"
            echo "ğŸŒ Server info: $(uname -a)"
            
            # Test connectivity from server side
            echo "ğŸ” Testing server connectivity..."
            ping -c 2 8.8.8.8 > /dev/null && echo "âœ… Internet connectivity OK" || echo "âš ï¸ Limited internet connectivity"
            
            # Test DNS resolution from server
            echo "ğŸ” Testing DNS from server..."
            nslookup google.com > /dev/null && echo "âœ… DNS working" || echo "âš ï¸ DNS issues on server"
            
            # Crear directorio del proyecto si no existe
            PROJECT_DIR="portafolios"
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "ğŸ“ Creating project directory..."
              mkdir -p "$PROJECT_DIR"
              cd "$PROJECT_DIR"
              
              echo "ğŸ“¦ Cloning repository..."
              for i in {1..3}; do
                if git clone https://github.com/${{ github.repository }}.git .; then
                  echo "âœ… Repository cloned successfully"
                  break
                else
                  echo "âš ï¸ Clone attempt $i/3 failed"
                  sleep 10
                fi
              done
            else
              echo "ğŸ“ Entering existing project directory..."
              cd "$PROJECT_DIR"
            fi
            
            # Verificar que es un repositorio git vÃ¡lido
            if [ ! -d ".git" ]; then
              echo "ğŸ”§ Initializing git repository..."
              rm -rf ./* ./.* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
            fi
            
            # Actualizar cÃ³digo con reintentos y mejor manejo de errores
            echo "ğŸ”„ Updating code from GitHub..."
            git config --global --add safe.directory $(pwd)
            
            for i in {1..5}; do
              if timeout 60s git fetch origin && git reset --hard origin/main; then
                echo "âœ… Git update successful"
                break
              else
                echo "âš ï¸ Git update failed, attempt $i/5"
                if [ $i -eq 5 ]; then
                  echo "âŒ All git update attempts failed"
                  echo "ğŸ”„ Continuing with existing code..."
                else
                  sleep 10
                fi
              fi
            done
            git clean -fd || true
            
            # Verificar archivos crÃ­ticos
            echo "ğŸ” Checking critical files..."
            ls -la Dockerfile docker-compose*.yml .env* || echo "Some files may be missing"
            
            # SIEMPRE crear archivo .env completo con todos los secrets de GitHub
            echo "ğŸ“ Creating complete .env configuration from GitHub Secrets..."
            cat > .env << EOF
            NODE_ENV=production
            PORT=3000
            NEXTAUTH_URL=https://herokku.duckdns.org
            DATABASE_URL=postgresql://postgres:${{ secrets.POSTGRES_PASSWORD }}@db:5432/portafolios
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=portafolios
            OAUTH_GITHUB_ID=${{ secrets.OAUTH_GITHUB_ID }}
            OAUTH_GITHUB_SECRET=${{ secrets.OAUTH_GITHUB_SECRET }}
            CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
            LOG_LEVEL=info
            ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
            ENCRYPTION_IV=${{ secrets.ENCRYPTION_IV }}
            CRON_SECRET_TOKEN=${{ secrets.CRON_SECRET_TOKEN }}
            EOF
            
            echo "âœ… .env created with all secrets from GitHub"
            echo "ğŸ“‹ Environment variables configured:"
            echo "   - NODE_ENV=production"
            echo "   - NEXTAUTH_URL=https://herokku.duckdns.org:8443"
            echo "   - DATABASE_URL=postgresql://postgres:****@db:5432/portafolios"
            echo "   - All secrets loaded from GitHub"
            
            # ğŸ”’ Configurar SSL si es necesario
            echo "ğŸ”’ Checking SSL configuration..."
            
            if [ ! -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
              echo "ğŸ“ Attempting SSL setup..."
              
              # Crear directorios necesarios
              mkdir -p certbot/conf certbot/www
              
              # Limpiar contenedores temporales anteriores
              echo "ğŸ§¹ Cleaning up any previous temporary containers..."
              docker stop certbot-standalone 2>/dev/null || true
              docker rm certbot-standalone 2>/dev/null || true
              docker compose down 2>/dev/null || true
              
              echo "ï¿½ Attempting to obtain SSL certificate from Let's Encrypt..."
              echo "ğŸ’¡ This requires port 80 to be accessible from the Internet"
              
              # Intentar obtener certificado
              docker run --rm --name certbot-standalone \
                -p 8080:80 \
                -v $(pwd)/certbot/conf:/etc/letsencrypt \
                certbot/certbot certonly \
                --standalone \
                --preferred-challenges http \
                --http-01-port 80 \
                --email ${{ secrets.LETSENCRYPT_EMAIL || 'admin@herokku.duckdns.org' }} \
                --agree-tos \
                --no-eff-email \
                --non-interactive \
                -d herokku.duckdns.org 2>&1 | tee /tmp/certbot.log
              
              # Verificar resultado
              if [ -f "certbot/conf/live/herokku.duckdns.org/fullchain.pem" ]; then
                echo "âœ… SSL certificate obtained successfully!"
              else
                echo "âš ï¸ Could not obtain SSL certificate"
                echo "ï¿½ Reason: Port 80 not accessible from Internet (firewall/NAT)"
                echo ""
                echo "ğŸ’¡ Solutions:"
                echo "   1. Configure port forwarding: 80 -> 8080 in your router"
                echo "   2. Use Cloudflare for automatic SSL (see HTTPS_SETUP.md)"
                echo "   3. Continue with HTTP on port 8130"
                echo ""
                echo "ğŸ“ For now, deploying with HTTP..."
              fi
            else
              echo "âœ… SSL certificates already exist"
            fi
            
            # Verificar Docker
            echo "ğŸ³ Checking Docker installation..."
            if ! docker --version; then
              echo "âŒ Docker not installed"
              exit 1
            fi
            
            if ! docker compose version; then
              echo "âŒ Docker Compose not available"
              exit 1
            fi
            
            # Test Docker functionality
            echo "ğŸ” Testing Docker functionality..."
            if timeout 60s docker run --rm hello-world > /dev/null 2>&1; then
              echo "âœ… Docker working properly"
            else
              echo "âš ï¸ Docker may have connectivity issues"
            fi
            
            # Verificar conflictos de puertos antes del deploy
            echo "ğŸ” Checking for port conflicts..."
            
            # Verificar puerto 8130 (aplicaciÃ³n)
            if ss -tlnp 2>/dev/null | grep -q ":8130 "; then
              echo "âš ï¸ Port 8130 is in use. Checking what's using it..."
              ss -tlnp 2>/dev/null | grep ":8130 "
              echo "ğŸ›‘ Attempting to stop any existing instances..."
              docker compose -f docker-compose.yml -f docker-compose.server.yml down || true
              pkill -f ":8130" || true
              sleep 5
            else
              echo "âœ… Port 8130 available"
            fi
            
            # Verificar puerto 5432 (PostgreSQL)
            if ss -tlnp 2>/dev/null | grep -q ":5432 "; then
              echo "âš ï¸ Port 5432 is in use (PostgreSQL conflict detected)"
              ss -tlnp 2>/dev/null | grep ":5432 "
              echo "ğŸ“ Note: Using internal-only PostgreSQL to avoid conflicts"
            else
              echo "âœ… Port 5432 available"
            fi
            
            # Mostrar estado actual antes de deploy
            echo "ğŸ“Š Current Docker status:"
            docker compose ps 2>/dev/null || echo "No containers currently running"
            
            # Detener servicios existentes con timeout
            echo "ğŸ›‘ Stopping existing services..."
            timeout 120s docker compose -f docker-compose.yml -f docker-compose.server.yml down || echo "Timeout stopping services"
            
            # Limpiar recursos con cuidado
            echo "ğŸ§¹ Cleaning up resources..."
            docker image prune -f || echo "Could not prune images"
            docker container prune -f || echo "Could not prune containers"
            
            # Verificar espacio en disco
            echo "ğŸ’¾ Checking disk space..."
            df -h . | tail -1
            
            # Estrategia de construcciÃ³n robusta con detecciÃ³n de conflictos
            echo "ğŸš€ Starting deployment with robust strategy..."
            
            # Configurar variables de entorno para Docker
            export DOCKER_BUILDKIT=1
            export BUILDKIT_PROGRESS=plain
            export COMPOSE_HTTP_TIMEOUT=1800
            export DOCKER_CLIENT_TIMEOUT=1800
            
            # Determinar configuraciÃ³n a usar
            echo "ï¿½ Using server configuration with Cloudflare Quick Tunnel"
            COMPOSE_CONFIG="-f docker-compose.yml -f docker-compose.server.yml"
            
            echo "ğŸ“‹ Using configuration: $COMPOSE_CONFIG"
            
            # Intentar diferentes estrategias
            DEPLOYMENT_SUCCESS=false
            
            # Estrategia 1: Build normal con configuraciÃ³n apropiada
            echo "ğŸ“‹ Strategy 1: Build with appropriate configuration..."
            for attempt in {1..2}; do
              echo "ğŸ”¨ Build attempt $attempt/2..."
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "âœ… Build successful on attempt $attempt"
                DEPLOYMENT_SUCCESS=true
                break
              else
                echo "âŒ Build failed on attempt $attempt"
                docker compose $COMPOSE_CONFIG down || true
                if [ $attempt -eq 1 ]; then
                  echo "â³ Waiting 60 seconds before retry..."
                  sleep 60
                fi
              fi
            done
            
            # Estrategia 2: Usar Dockerfile estable si existe
            if [ "$DEPLOYMENT_SUCCESS" = false ] && [ -f "Dockerfile.stable" ]; then
              echo "ğŸ“‹ Strategy 2: Using stable Dockerfile..."
              
              # Backup y usar Dockerfile estable
              cp Dockerfile Dockerfile.backup 2>/dev/null || true
              cp Dockerfile.stable Dockerfile
              
              if timeout 1800s docker compose $COMPOSE_CONFIG up -d --build; then
                echo "âœ… Deployment successful with stable Dockerfile"
                DEPLOYMENT_SUCCESS=true
              else
                echo "âŒ Stable Dockerfile also failed"
                # Restaurar Dockerfile original
                cp Dockerfile.backup Dockerfile 2>/dev/null || true
              fi
            fi
            
            # Estrategia 3: Usar imÃ¡genes existentes
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "ğŸ“‹ Strategy 3: Using existing images..."
              
              if docker images | grep -q portafolios; then
                echo "ğŸ“¦ Found existing images, attempting deployment..."
                if docker compose $COMPOSE_CONFIG up -d; then
                  echo "âœ… Deployment successful with existing images"
                  DEPLOYMENT_SUCCESS=true
                else
                  echo "âŒ Existing images deployment failed"
                fi
              else
                echo "âŒ No existing images found"
              fi
            fi
            
            # Verificar resultado del deployment
            if [ "$DEPLOYMENT_SUCCESS" = false ]; then
              echo "âŒ All deployment strategies failed"
              echo "ğŸ“‹ Final logs:"
              docker compose logs --tail=30 2>/dev/null || echo "Could not fetch logs"
              exit 1
            fi
            
            # Esperar a que los servicios se estabilicen
            echo "â³ Waiting for services to stabilize..."
            sleep 90
            
            # Verificar estado de los servicios
            echo "âœ… Final service status:"
            docker compose ps
            
            # Verificar que los contenedores estÃ¡n corriendo
            if ! docker compose ps | grep -q "Up"; then
              echo "âŒ No containers are running. Checking logs..."
              docker compose logs --tail=30
              exit 1
            fi
            
            # Mostrar logs recientes de la aplicaciÃ³n
            echo "ğŸ“‹ Recent application logs:"
            docker compose logs --tail=25 app || echo "Could not fetch app logs"
            
            # Test de salud de la aplicaciÃ³n con reintentos
            echo "ğŸ” Testing application health..."
            
            HEALTH_URL="http://localhost:8130"
            APP_URL="http://localhost:8130"
            
            for i in {1..10}; do
              if curl -f -m 20 ${HEALTH_URL}/api/health 2>/dev/null; then
                echo "âœ… Health check successful - API responding"
                break
              elif curl -f -m 20 ${APP_URL} 2>/dev/null; then
                echo "âœ… Main application responding"
                break
              else
                echo "â³ Health check attempt $i/10 failed, retrying in 15s..."
                if [ $i -eq 10 ]; then
                  echo "âš ï¸ Health checks failed, checking system status..."
                  echo "ğŸ” Port status:"
                  ss -tlnp 2>/dev/null | grep -E ':(8080|8443|8130) ' || echo "Expected ports not listening"
                  echo "ğŸ” Process status:"
                  docker compose top 2>/dev/null || echo "Could not get process info"
                  echo "ğŸ“‹ Container logs:"
                  docker compose logs --tail=15 app
                  echo "ğŸ’¡ Application may still be starting up"
                else
                  sleep 15
                fi
              fi
            done
            
            # InformaciÃ³n final
            echo "ğŸ‰ Deployment process completed!"
            echo ""
            echo "ğŸŒ Application URLs:"
            echo "   - HTTPS: https://herokku.duckdns.org"
            echo "   - HTTP (Direct): http://herokku.duckdns.org:8130"
            echo ""
            echo "ğŸ” Health endpoint: https://herokku.duckdns.org/api/health"
            echo ""
            echo "âœ… SSL/HTTPS enabled via Cloudflare Tunnel"
            echo ""
            echo "ğŸ“Š Container status:"
            docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            
            echo "ğŸ’¡ If the application is not immediately available:"
            echo "   - Check logs: docker compose logs -f app"
            echo "   - Check status: docker compose ps"
            echo "   - Wait a few more minutes for startup"

  notify:
    name: ğŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
      - name: ğŸ‰ Success Notification
        if: needs.deploy.result == 'success'
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸŒ Application URL with HTTPS:"
          echo "   https://herokku.duckdns.org"
          echo ""
          echo "ğŸ”’ SSL enabled via Cloudflare Tunnel"
          echo "ğŸ“ Your DuckDNS domain now has HTTPS!"
          
      - name: âŒ Failure Notification
        if: needs.deploy.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "ğŸ” Check server connectivity and SSH credentials"
